<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[圣杯布局和双飞翼布局介绍]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[圣杯布局介绍圣杯布局是讨论「三栏液态布局」的实现，它最早出自于谁或许不得而查了，但最早的完美实现是来自于 Matthew Levine 于2006年在「A LIST APART」上写的一篇文章，它主要讲述了网页中关于最佳圣杯的实现方法。地址 所谓液态布局是相对固态布局而言的，固态布局就是固定值不变的布局，液态就好比在容器里到了一杯水，它可以随着容器宽度的变化而自适应宽度。 一般来说，在正常的DOW树中表现为先写Left，然后Middle，最后Right，它可能会导致代码不够灵活，尤其是从DOM的载入顺序来说，中间的内容不能被首先加载； 因此提出者给出了一个较好的方案： 两边带有固定宽度中间可以流动（fluid）； 允许中间一栏最先出现； 允许任意一栏放在最上面； 仅需一个额外的 div 标签 仅需非常简单的 CSS，带上最少的兼容性补丁 最终效果：地址 实现方式例如，我们现在需要一个左边宽度为200px，右边宽度为150px，中间宽度为流动的布局； 基本html代码： 1234567&lt;div id="header"&gt;#header&lt;/div&gt;&lt;div id="container"&gt; &lt;div id="center" class="column"&gt;#center&lt;/div&gt; &lt;div id="left" class="column"&gt;#left&lt;/div&gt; &lt;div id="right" class="column"&gt;#right&lt;/div&gt;&lt;/div&gt;&lt;div id="footer"&gt;#footer&lt;/div&gt; css部分： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#container &#123; padding-left: 200px; padding-right: 150px; overflow: hidden;&#125;#container .column &#123; height: 200px; position: relative; float: left;&#125;#center &#123; background: #e9e9e9; width: 100%;&#125;#left &#123; width: 200px; right: 200px; background: red; margin-left: -100%;&#125;#right &#123; width: 150px; background: blue; margin-right: -150px;&#125;#footer &#123; clear: both;&#125;#header,#footer &#123; background-color: #c9c9c9; text-align: center; padding: 20px 0; color: #fff;&#125;/*** IE6 Fix ***/* html #left &#123; left: 150px; /* RC width */&#125; 双飞翼布局介绍与圣杯布局相比，双飞翼HTML中为中间元素添加了一个子元素center-wrap,这个小小的改动是为了之后处理中间内容被遮盖的问题，这也是两者实现方式最大的不同点，下面继续。 基本html结构： 12345678910111213&lt;div id="container"&gt; &lt;div id="center" class="col"&gt; &lt;div id="center-wrap"&gt; #center &lt;/div&gt; &lt;/div&gt; &lt;div id="left" class="col"&gt; #left &lt;/div&gt; &lt;div id="right" class="col"&gt; #right &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627.col &#123; float: left;&#125;#center &#123; width: 100%; height: 400px; background-color: #ccc;&#125;#center-wrap &#123; margin: 0 150px 0 200px;&#125;#left &#123; width: 200px; height: 400px; margin-left: -100%; background-color: #0000FF;&#125;#right &#123; width: 150px; height: 400px; margin-left: -150px; background-color: #FF0000;&#125; 最终效果：地址 总结： 与圣杯布局相比较，双飞翼布局相对来说能更好的理解，代码量也相对较少，也没有使用相对定位这些敏感的属性， 建议使用双飞翼布局；]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七种实现左侧固定，右侧自适应两栏布局的方法]]></title>
    <url>%2F2018%2F05%2F25%2Flayout%2F</url>
    <content type="text"><![CDATA[总结一下左边固定，右边自适应的两栏布局的七种方法。其中有老生常谈的float方法,BFC方法，也有CSS3的flex布局与grid布局。并非所有的布局都会在开发中使用，但是其中也会涉及一些知识点。关于最终的效果，可以查看这里 注：在这里block就是指块级元素，inline就是指行内元素;首先创建基本的HTML布局和最基本的样式。 123456789&lt;div class="wrapper"&gt; &lt;div class="left"&gt; 左边固定宽度，高度不固定,高度有可能会很小，也可能很大。 &lt;/div&gt; &lt;div class="right"&gt; 这里的内容可能比左侧高，也可能比左侧低。宽度需要自适应。&lt;/br&gt; 基本的样式是，两个div相距20px, 左侧div宽 120px &lt;/div&gt;&lt;/div&gt; 基本的样式是，两个盒子相距20px, 左侧盒子宽 120px，右侧盒子宽度自适应。基本的CSS样式如下: 123456789101112.wrapper &#123; padding: 15px 20px; border: 1px dashed #ff6c60;&#125;.left &#123; width: 120px; border: 5px solid #ddd;&#125;.right &#123; margin-left: 20px; border: 5px solid #ddd;&#125; 下面的代码都是基于这套基本代码做覆盖，通过给容器添加不同的类来实现效果。 双inline-block方案12345678910111213141516.wrapper-inline-block &#123; box-sizing: border-box; font-size: 0; /* 消除空格的影响 */&#125;.wrapper-inline-block .left,.wrapper-inline-block .right &#123; display: inline-block; vertical-align: top; /*顶端对齐*/ font-size: 14px; box-sizing: border-box;&#125;.wrapper-inline-block .right &#123; width: calc(100% - 140px); /*这里使用了calc函数，来进行响应式布局*/&#125; 这种方法是通过width: calc(100% - 140px)来动态计算右侧盒子的宽度。需要知道右侧盒子距离左边的距离，以及左侧盒子具体的宽度(content+padding+border)，以此计算父容器宽度的100%需要减去的数值。同时，还需要知道右侧盒子的宽度是否包含border的宽度。在这里，为了简单的计算右侧盒子准确的宽度，设置了子元素的box-sizing:border-box;以及父元素的box-sizing: content-box;。同时，作为两个inline-block的盒子，必须设置vertical-align来使其顶端对齐。另外，为了准确地应用计算出来的宽度，需要消除div之间的空格，需要通过设置父容器的font-size: 0;,或者用注释消除html中的空格等方法。 缺点 : 需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的box-sizing 需要消除空格字符的影响 （内联元素会受换行的影响，而有空白字符） 需要设置vertical-align: top满足顶端对齐。 双float方案1234567891011121314.wrapper-double-float &#123; overflow: hidden; /*清除浮动*/ box-sizing: border-box;&#125;.wrapper-double-float .left,.wrapper-double-float .right &#123; float: left; box-sizing: border-box;&#125;.wrapper-double-float .right &#123; width: calc(100% - 140px);&#125; 本方案和双inline-block方案原理相同，都是通过动态计算宽度来实现自适应。但是，由于浮动的block元素在有空间的情况下会依次紧贴，排列在一行，所以无需设置display: inline-block;，自然也就少了顶端对齐，空格字符占空间等问题。不过由于应用了浮动，父元素需要清除浮动。 缺点 : 需要知道左侧盒子的宽度，两个盒子的距离，还要设置各个元素的box-sizing。 父元素需要清除浮动。 清楚浮动的方法请移步这里 float+margin-left方案1234567891011.wrapper-float &#123; overflow: hidden; /*清除浮动*/&#125;.wrapper-float .left &#123; float: left;&#125;.wrapper-float .right &#123; margin-left: 150px;&#125; 上面两种方案都是利用了CSS的calc()函数来计算宽度值。下面两种方案则是利用了block级别的元素盒子的宽度具有填满父容器，并随着父容器的宽度自适应的流动特性。但是block级别的元素都是独占一行的，所以要想办法让两个block排列到一起。我们知道，block级别的元素会认为浮动的元素不存在，但是inline级别的元素能识别到浮动的元素。这样，block级别的元素就可以和浮动的元素同处一行了。为了让右侧盒子和左侧盒子保持距离，需要为左侧盒子留出足够的距离。这个距离的大小为左侧盒子的宽度以及两个盒子之间的距离之和。然后将该值设置为右侧盒子的margin-left。 缺点 : 需要清除浮动 需要计算右侧盒子的margin-left 使用absolute+margin-left方法另外一种让两个block排列到一起的方法是对左侧盒子使用position: absolute的绝对定位。这样，右侧盒子也能无视掉它。 123456789.wrapper-absolute .left &#123; position: absolute; top: 0; left: 0；&#125;.wrapper-absolute .right &#123; margin-left: 150px;&#125; 缺点 : 使用了绝对定位，若是用在某个div中，需要更改父容器的position。 没有清除浮动的方法，若左侧盒子高于右侧盒子，就会超出父容器的高度。因此只能通过设置父容器的min-height来放置这种情况。（因为定位元素已经脱离正常的文档流） 使用float+BFC方法上面的方法都需要通过左侧盒子的宽度，计算某个值，下面三种方法都是不需要计算的。只需要设置两个盒子之间的间隔。 W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。 为了便于理解，我们换一种方式来重新定义BFC。一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可： float的值不是none。 position的值不是static或者relative。 display的值是inline-block、table-cell、flex、table-caption或者inline-flex overflow的值不是visible BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 12345678910111213.wrapper-float-bfc &#123; overflow: hidden;&#125;.wrapper-float-bfc .left &#123; float: left; margin-right: 20px;&#125;.wrapper-float-bfc .right &#123; margin-left: 0; overflow: auto;&#125; 这个方案同样是利用了左侧浮动，但是右侧盒子通过overflow: auto;形成了BFC，因此右侧盒子不会与浮动的元素重叠。 这种情况下，只需要为左侧的浮动盒子设置margin-right，就可以实现两个盒子的距离了。而右侧盒子是block级别的，所以宽度能实现自适应。 缺点 : 父元素需要清除浮动 flex方案flex弹性布局文档 123456789101112.wrapper-flex &#123; display: flex; align-items: flex-start;&#125;.wrapper-flex .left &#123; flex: 0 0 auto;&#125;.wrapper-flex .right &#123; flex: 1 1 auto;&#125; flex可以说是最好的方案了，代码少，使用简单。有朝一日，大家都改用现代浏览器，就可以使用了。需要注意的是，flex容器的一个默认属性值:align-items: stretch;。这个属性导致了列等高的效果。为了让两个盒子高度自动，需要设置: align-items: flex-start; grid方案grid二维布局文档 又一个新型的布局方式。可以满足需求，但这并不是它发挥用处的真正地方。 123456789101112131415161718.wrapper-grid &#123; display: grid; grid-template-columns: 120px 1fr; align-items: start;&#125;.wrapper-grid .left,.wrapper-grid .right &#123; box-sizing: border-box;&#125;.wrapper-grid .left &#123; grid-column: 1;&#125;.wrapper-grid .right &#123; grid-column: 2;&#125; 注意: grid布局也有列等高的默认效果。需要设置: align-items: start;。 grid布局还有一个值得注意的小地方和flex不同:在使用margin-left的时候，grid布局默认是box-sizing设置的盒宽度之间的位置。而flex则是使用两个div的border或者padding外侧之间的距离。 极限情况最后可以再看一下在父容器极限小的情况下，不同方案的表现。主要分成四种情况： 动态计算宽度的情况:两种方案: 双inline-block方案和双float方案。宽度极限小时，右侧的div宽度会非常小，由于遵循流动布局，所以右侧div会移动到下一行。 动态计算右侧margin-left的情况: 两种方案: float+margin-left方案和absolute+margin-left方案。宽度极限小时，由于右侧的div忽略了文档流中左侧div的存在，所以其依旧会存在于这一行，并被隐藏。 float+BFC方案的情况: 这种情况下，由于BFC与float的特殊关系，右侧div在宽度减小到最小后，也会掉落到下一行。 flex和grid的情况: 这种情况下，默认两种布局方式都不会放不下的div移动到下一行。不过 flex布局可以通过 flex-flow: wrap;来设置多余的div移动到下一行。 grid布局暂不支持。 注：本文摘录出自这里]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS布局-对齐方式]]></title>
    <url>%2F2018%2F05%2F24%2Fcssalign%2F</url>
    <content type="text"><![CDATA[一、水平居中行内元素的水平居中如果被设置元素为文本、图片等行内元素时，在父元素中设置text-align:center实现行内元素水平居中，将子元素的display设置为inline-block，使子元素变成行内元素，这时候行内元素不会继承父元素的宽度，它宽度为其内容的宽度； 12345&lt;div class="parent"&gt; &lt;div class="child"&gt; &lt;p&gt;Demo&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011body&#123; margin:0;&#125;.parent&#123; background: #333; text-align: center;&#125;.child&#123; display: inline-block; background: #ccc;&#125; 块状元素的水平居中（定宽）当被设置元素为定宽块级元素时用 text-align:center 就不起作用了。可以通过设置“左右margin”值为“auto”来实现居中的。 123&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112body&#123; margin:0;&#125;.parent&#123; background: #333;&#125;.child&#123; width: 200px; height: 50px; margin: 0 auto; background: #ccc;&#125; 块状元素的水平居中（不定定宽）在实际工作中我们会遇到需要为“不定宽度的块级元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。 可以直接给不定宽的块级元素设置text-align：center来实现，也可以给父元素加text-align:center 来实现居中效果。（文字内容区域居中） 当不定宽块级元素的宽度不要占一行时，可以设置display 为 inline 类型或inline-block（设置为 行内元素 显示或行内块元素） 1234567&lt;div class="container"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 123456789101112131415161718192021body&#123; margin:0;&#125;.container&#123; text-align:center; background: #333&#125;.container ul&#123; list-style:none; margin:0; padding:0; display:inline-block;&#125;.container li&#123; margin-right:8px; display:inline-block;&#125;.container li a&#123; color: #fff; text-decoration: none;&#125; 二、垂直居中首先设定两个条件，父元素是盒子元素且高度已经固定 子元素是行内元素，高度是由其内容撑开这种情况下，需要通过设定父元素的line-height为其高度来使得子元素垂直居中（line-height子元素是可以继承的，所以给父元素或者子元素设置都可以） 123&lt;div class="container"&gt; &lt;p&gt;demo&lt;/p&gt;&lt;/div&gt; 1234567891011body&#123; margin:0;&#125;.container&#123; background: #333; height: 200px;&#125;.container p&#123; color: #fff; line-height: 200px;&#125; 子元素是块级元素（定高或者不定高）在这里可以使用相对定位进行操作 123&lt;div class="wrap"&gt; &lt;div class="child"&gt;demo&lt;/div&gt;&lt;/div&gt; 123456789101112131415body&#123; margin:0;&#125;.wrap&#123; width: 100%; background: #333; height: 200px; &#125;.child&#123; background: #ccc; position: relative; top: 50%; transform: translateY(-50%);&#125; 水平垂直居中水平对齐+行高 123&lt;div class="wrap"&gt; &lt;p&gt;demo&lt;/p&gt;&lt;/div&gt; 12345678910111213body&#123; margin:0;&#125;.wrap&#123; width: 100%; background: #333; height: 200px; line-height: 200px; text-align: center;&#125;.wrap p&#123; color: #fff&#125; 水平+垂直对齐text-align + vertical-align在父元素设置text-align和vertical-align，并将父元素设置为table-cell元素，子元素设置为inline-block元素 123&lt;div class="wrap"&gt; &lt;div class="container"&gt;demo&lt;/div&gt;&lt;/div&gt; 123456789101112131415body&#123; margin:0;&#125;.wrap&#123; width: 1%; padding: 80px 0; text-align: center; vertical-align: middle; display: table-cell; background: #333;&#125;.container&#123; background: #ccc; display: inline-block;&#125; 若子元素是图像，可不使用table-cell，父元素用行高替代高度，且字体大小设为0。子元素本身设置vertical-align:middle既然设置为内联那么就会受空白区域的影响，这时候就需要用font-size:0 123&lt;div class="parent"&gt; &lt;img class="child"&gt;&lt;/div&gt; 12345678.parent&#123; text-align: center; line-height: 100px; font-size: 0;&#125;.child&#123; vertical-align: middle;&#125; 相对+绝对定位使用absolute，利用绝对定位元素的盒模型特性，在偏移属性为确定值的基础上，设置margin:auto 123&lt;div class="wrap"&gt; &lt;div class="container"&gt;demo&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920body&#123; margin:0;&#125;.wrap&#123; position: relative; background-color: #333; /* height:100px; */ padding: 80px 0;&#125;.container&#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; height: 50px; width: 80px; margin: auto; background: #ccc;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UED 素质扩展之趣味乒乓球比赛]]></title>
    <url>%2F2018%2F05%2F08%2Fued-family%2F</url>
    <content type="text"><![CDATA[活动主题：素质扩展之趣味乒乓球比赛; 活动目的：为了丰富大家的文化生活，培养大家团队意识，为大家的生活、工作带来乐趣，特举行乒乓球趣味活动，希望大家踊跃参加; 活动形式：首先进行乒乓球趣味赛，其次进行乒乓球团体赛; 活动时间：2018-5-10 ~ 2018-5-31; 活动地点：研发大楼14楼，乒乓球室; 活动流程：主持及裁判人：韩森、徐雅茹 ** 暂定 （共三位、裁判也是参赛选手） 乒乓球趣味赛：根据团队人员共分为4个组，每组5人，每次进行一个项目趣味比赛，两两对抗；（每周两次，每次保证全员参与）； 乒乓球团体赛：根据团队人员共分为两个队，队长分别是：李芳菲和黑淑君，首先进行两次的团队内部的淘汰赛，每个队伍选出5个人，然后进行两个队伍之间的PK，五局制； 奖项设置： 趣味奖: 四个队伍中评选出一个（每队4人）; 团体奖：二个队伍中评选出一个（每队8人）; 具体比赛规则乒乓球趣味赛比赛项目:一、接力托球折返跑 四个队的队员站成一排; 乒乓球放在球拍的中间，每人托运一个球; 比赛的过程中手不能触及到球; 从出发点到折返点，再从折返点返回出发点，交给另外一个人继续托运。; 如果球在比赛途中掉落在地上，选手必须捡起球重新开始比赛; 在规定的赛程内用时最少的队伍获胜; 二、吹乒乓球 每个队伍选出2~3三人，两个队伍之间进行对抗比赛，用时总和最少者为获胜方； 桌上放着十个等高的一次性纸杯，一次紧接着竖排，杯子里装满水，第一个杯子放一个乒乓球; 参赛者要将乒乓球从第一个杯子吹向第二个杯子，一个接一个地吹，乒乓球不能跳杯子，不能落到地上，直到从最后一个杯子吹出; 比赛的过程中手不能触及到球; 三、夹运乒乓球 每个队伍全员参与，两个队伍之间进行对抗比赛，用时总和最少者为获胜方； 桌子上放着5个乒乓球，选手需用筷子从甲地，运到乙地; 比赛的过程中手不能触及到球 三、趣味双打 每组派2人参加（不限男女，自由组合），要求将每位选手的左腿与同伴右腿绑在一起; 先A组与B组PK，共打5个球，输者淘汰，输方另派2人参赛，直至决出胜方; 后C组与D组PK，同样打5个球，输者淘汰，输方另派2人参赛，直至决出胜方; 先比赛的胜方与后比赛的胜方进行PK，赛制同上，直至决出胜方; 暂定4个趣味比赛项目，如有其他更有意思的玩法，欢迎推荐！ 乒乓团体赛项目:根据团队人员共分为两个队： 队伍 队长 队员 红队 菲姐 待定（8人） 蓝队 黑姐 待定（8人） 队伍内部淘汰赛： 每队内部成员进行两两对抗; 采用5局三胜制，队长自由分配队员对赛; 根据赛制，由队长挑选五位胜出者，参加团队对抗赛; 团队对抗赛: 每个队伍每次挑选出一人，迎战对方队伍; 总共进行5轮比赛，每轮5局三胜制; 5轮获胜最多的队伍为最终胜利者; 趣味活动、欢乐比赛 友谊第一、比赛第二 最终解释权：* 森]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>乒乓球</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack基本配置]]></title>
    <url>%2F2018%2F04%2F26%2Fwebpack-project%2F</url>
    <content type="text"><![CDATA[前言现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决Sass，Less……新增样式的扩展写法的编译工作。所以现代化的前端已经完全依赖于WebPack的辅助了。 现在最流行的三个前端框架，可以说和webpack已经紧密相连，框架官方都推出了和自身框架依赖的webpack构建工具。 React.js+WebPack Vue.js+WebPack AngluarJS+WebPack 安装在安装webpack的之前，你首先要安装node、npm，因为webpack是一个基于node的项目，然后 cnpm install -g webpack 介绍webpack简介： webpack旨意；让一切变得简单，定义：MODULE BUNDLER 他的目的就是把有依赖关系的各种文件打包成一系列的静态资源。 请看下图 webpack简单点来说就就是一个配置文件，所有的魔力都是在这一个文件中发生的。后期可以根据自己项目的需求，逐渐去添加各种配置文件，完成自己的webpack脚手架。 刚开始配置文件主要分为三大块： entry 入口文件 让webpack用哪个文件作为项目的入口 output 出口 让webpack把处理完成的文件放在哪里 module 模块 要用什么不同的模块来处理各种类型的文件 简单Demo创建并格式化项目项目 123mkdir londy-webpackcd londy-webpackcnpm init 输入完成后，npm终端会问你关于项目的名称，描述……一堆内容，这些内容都不重要，而且我们后期还可以用文本的形式修改这些内容。现在我们只要一路回车就完成了初始化。这时候可以在根目录看到生成的package.json文件了 里面包含了此项目的一些信息。 安装webpack-cli4.X之后的版本，CLI（命令行工具）已经转移到了一个单独的包webpack-cli中。除了webpack自身外，请额外安装webpack-cli来使用CLI。 cnpm install -g webpack-cli 尽量全局安装 cnpm install webpack-cli -D 这里-D参数和–save-dev的作用相同，只是一种简写而已 如果你使用git管理你的这个项目的话，建议你新建一个.gitignore文件，不要让git提交一些node依赖的模块 node_modules 建立基本项目结构创建入口文件 在根目录下创建src文件夹，并创建index.js入口文件 在根目录下创建dist文件夹，并创建一个基本的index.html文件，在body中引入编译后的main.js webpack4.x是以项目根目录下的’./src’作为入口，webpack4.x的打包已经不能用webpack 文件a 文件b的方式,其中src目录即index.js文件需要手动创建，而dist目录及main.js会自动生成。因此我们不再按webpack 文件a 文件b的方式运行webpack指令，而是直接运行 webpack --mode development或webpack --mode production 设置模式在这里有两种模式： 开发环境：webpack --mode development 生产环境：webpack --mode production 编辑package.json这个文件中的scripts中加入两个成员 12345"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "dev": "webpack --mode development", //开发环境 "build":"webpack --mode production" //生产环境&#125; 三、配置文件webpack.config.js就是Webpack的配置文件，这个文件需要自己在项目根目录下手动建立。建立好后我们对其进行配置。 这是一个没有内容的标准webpack配置模版： 1234567module.exports=&#123; entry:&#123;&#125;, //入口文件的配置项 单一入口或者多入口 output:&#123;&#125;, //出口文件的配置项 支持多出口配置 module:&#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 plugins:[], //插件，用于生产模版和各项功能 devServer:&#123;&#125; //配置webpack开发服务功能&#125; 基本配置1234567891011const path = require('path');module.exports = &#123; entry: './src/index.js', //入口文件的配置项 单一入口或者多入口 output: &#123; path: path.join(__dirname, 'dist'), // 出口目录，dist文件 filename: '[name].[hash].js' //这里name就是打包出来的文件名，因为是单入口，就是main &#125;, module: &#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 plugins: [], //插件，用于生产模版和各项功能 devServer: &#123;&#125; //配置webpack开发服务功能&#125; 多入口、多出口配置123456789101112131415const path = require('path');module.exports = &#123; entry: &#123; main: './src/main.js', index: './src/index.js', &#125;, //入口文件的配置项 单一入口或者多入口 output: &#123; path: path.join(__dirname, 'dist'), // 出口目录，dist文件 filename: '[name].[hash].js' //这里name就是打包出来的文件名，因为是单入口，就是main &#125;, module: &#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 plugins: [], //插件，用于生产模版和各项功能 devServer: &#123;&#125; //配置webpack开发服务功能&#125; 配置webpack-dev-server首先安装 npm install webpack-dev-server -D 修改webpack.config.js 1234567devServer: &#123; contentBase: path.join(__dirname, "dist"), //静态文件根目录 port: 9090, // 端口 host: 'localhost', overlay: true, compress: true // 服务器返回浏览器的时候是否启动gzip压缩&#125; 修改package.json 123"scripts": &#123; "dev": "webpack-dev-server --open --mode development"&#125; 一个基于基本配置的demo就完成了 直接运行 cnpm run build 就可以看到页面打包的情况了。 常用lodaer及插件介绍Loaders是Webpack最重要的功能之一，他也是Webpack如此盛行的原因。通过使用不同的Loader，Webpack可以的脚本和工具，从而对不同的文件格式进行特定处理。 Loaders实例： 可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。 可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。 可以把React中的JSX转换成JavaScript代码。 注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。下面我们对Loaders的配置型简单梳理一下。 test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的； use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错； include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选）。 模块：CSS文件打包命令： cnpm i style-loader css-loader -D webpack.config.js Loaders的配置如下 12345678rules: [ &#123; test: /\.css$/, use: ['style-loader','css-loader'], include: path.join(__dirname, 'src'), //限制范围，提高打包速度 exclude: /node_modules/ &#125;] css-loader用来处理css中url的路径 style-loader可以把css文件变成style标签插入head中 多个loader是有顺序要求的，从右往左写，因为转换的时候是从右往左转换的 打包HTML文件首先安装插件cnpm install --save-dev html-webpack-plugin 配置webpack.config.js文件 1234567new htmlPlugin(&#123; minify:&#123; removeAttributeQuotes:true &#125;, hash:true, template:'./src/index.html'&#125;) minify：是对html文件进行压缩，removeAttrubuteQuotes是却掉属性的双引号。 hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 template：是要打包的html模版路径和文件名称。 CSS中的图片处理安装命令：cnpm i file-loader url-loader -D 然后在weboack文件中配置如下： 123456789&#123; test: /\.(png|jpg|gif)/, use: [&#123; loader: 'url-loader', options: &#123; limit: 500000 &#125; &#125;]&#125; limit是用来判断其图片大小，进行不同的处理方式，当小于设定的值会打包为base64格式的 file-loader是解析图片地址，把图片从源文件拷贝到目标文件并且修改源文件名字 url-loader可以在文件比较小的时候，直接变成base64字符串内嵌到页面中 我们需要了解file-loader和url-loader的关系。url-loader和file-loader是什么关系呢？简答地说，url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况： 文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）； 文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。 也就是说，其实我们只安装一个url-loader就可以了 CSS分离与图片路径处理第一个是把CSS从JavasScript代码中分离出来，第二个是如何处理分离出来后CSS中的图片路径不对问题 CSS分离:extract-text-webpack-plugin安装： cnpm i extract-text-webpack-plugin -D引入： const extractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;)设置Plugins: new extractTextPlugin(&quot;/css/index.css&quot;)这里的/css/index.css是分离后的路径位置。这部配置完成后，包装代码：还要修改原来我们的style-loader和css-loader。 在webpack.config.js中修改配置 123456789&#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: "style-loader", use: "css-loader" &#125;), include: path.join(__dirname, 'src'), //限制范围，提高打包速度 exclude: /node_modules/&#125; plugins设置保存css的路径 123new extractTextPlugin(&#123; filename: 'css/[name].[hash].css'&#125;) 如果最后打包出现错误则安装cnpm i extract-text-webpack-plugin@next -D 针对webpack4.x 图片保存路径12345678910&#123; test: /\.(png|jpg|gif|jpeg|svg)/, use: [&#123; loader: 'url-loader', options: &#123; outputPath: 'images/', //图片输出路径 limit: 5*1024 &#125; &#125;]&#125; 修改出口配置 12345output: &#123; path: path.join(__dirname, 'dist'), // 出口目录，dist文件 filename: '[name].js', //这里name就是打包出来的文件名，因为是单入口，就是main，多入口下回分解 publicPath: '/' //同时要处理打包图片路径问题&#125; 处理在html中引入图片打包问题安装：cnpm install html-withimg-loader --save配置loader: 1234&#123; test: /\.(htm|html)$/i, use:[ 'html-withimg-loader'] &#125; SASS文件的打包和分离首先需要安装两个插件node-sass和sass-loader其次在配置文件中配置loader 1234567891011&#123; test: /\.sass$/, use: ExtractTextWebpackPlugin.extract(&#123; use: [&#123; loader: 'css-loader' &#125;,&#123; loader: 'sass-loader' &#125;], fallback: 'style-loader' &#125;)&#125; 自动处理CSS3属性前缀PostCSS PostCSS是一个CSS的处理平台，它可以帮助你的CSS实现更多的功能，但是今天我们就通过其中的一个加前缀的功能，初步了解一下PostCSS。 需要安装两个包postcss-loader 和autoprefixer（自动添加前缀的插件） cnpm install --save-dev postcss-loader autoprefixer postcss.config.js postCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。 12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 这就是对postCSS一个简单的配置，引入了autoprefixer插件。让postCSS拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。 其次修改我们的webpack.config,js 12345678910&#123; test: /\.css$/, use: extractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, 'postcss-loader' ] &#125;)&#125; 消除未使用的CSScnpm i -D purifycss-webpack purify-css 引入glob 因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。在webpack.config.js文件头部引入glob。 引入purifycss-webpack 同样在webpack.config.js文件头部引入purifycss-webpack const PurifyCSSPlugin = require(&quot;purifycss-webpack&quot;) 在webpack.config.js中添加配置 123new PurifyCSSPlugin(&#123; paths: glob.sync(path.join(__dirname, 'src/*.html')),&#125;) 给webpack增加babel支持Babel是什么？ 就是一个转码器 Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过便宜帮你达到以下目的： 使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。 使用基于JavaScript进行了扩展的语言，比如React的JSX。 我们先一次性安装这些依赖包cnpm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react .babelrc配置 因为babely有很多的配置项，为了以后不必要的麻烦直接在根目录下创建.babelrc文件 123&#123; "presets":["react","es2015"]&#125; .webpack.config.js里的loader配置 1234567&#123; test:/\.(jsx|js)$/, use:&#123; loader:'babel-loader', &#125;, exclude:/node_modules/&#125; 在这里也可以使用另外一种转码方式env 安装第三方库 Jquerycnpm install --save jquery 安装时需要注意的时Jquery最终要在生产环境中使用，所以我们这里要使用–save进行安装。 引入方式选择用plugin全局引入： ProvidePlugin是一个webpack自带的插件，Provide的意思就是装备、提供。因为ProvidePlugin是webpack自带的插件，所以要先再webpack.config.js中引入webpack。 const webpack = require(&#39;webpack&#39;) 然后在plugins模块添加： 123new webpack.ProvidePlugin(&#123; $:&quot;jquery&quot;&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费SSL证书 : Let’s Encrypt安装使用教程: Nginx配置SSL]]></title>
    <url>%2F2017%2F10%2F29%2F%E5%85%8D%E8%B4%B9SSL%E8%AF%81%E4%B9%A6-Let%E2%80%99s-Encrypt%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-Nginx%E9%85%8D%E7%BD%AESSL%2F</url>
    <content type="text"><![CDATA[一 、快速获取Let’s Encrypt免费SSL证书首先确保你的系统已安装git，然后再进行以下操作： 在这里只介绍常用的两个获取证书的模式Standalone使用独立模式进行自动验证，需要在 目标服务器 上运行 Let’s Encrypt 客户端，并指定 certonly 和 –standalone参数。本模式需要绑定 80 或 443 端口进行域名验证，所以如果服务器上已有web server运行并侦听这2个端口，则需要先关闭web server。 运行命令： 1./letsencrypt-auto certonly --standalone -d yourwebsite.com --email youremail.com Webroot如果 目标服务器 已有web server运行，并且不能够关闭服务来获取和安装证书，可以使用 Webroot plugin。在运行 Let’s Encrypt 客户端时指定 certonly和 –webroot 参数，并使用 –webroot-path 或-w 参数来指定 webroot 目录，比如 –webroot-path /web/www 运行命令： 12./letsencrypt-auto certonly --standalone -d yourwebsite.com --email youremail.com./letsencrypt-auto certonly --webroot --webroot-path /web/www -d yourwebsite.com --agree-tos --email youremail 以下是使用独立模式来获取证书的：123git clone https://github.com/letsencrypt/letsencrypt cd letsencrypt./letsencrypt-auto certonly --standalone -d yourwebsite.com --email youremail.com 上述命令中yourwebsite.com为你的域名，如果有二级域名则在后面继续加 -d hs.yourwebsite.com , --email 参数后面需要填写你的邮箱。如果不写邮箱这个参数，在安装过程中会提示让你输入你的邮箱（邮箱也是很重要的，在后期证书到期并且没有自动续期，会给你发邮件提示的）。 可能会出现错误： 1OSError: Command /opt/eff.org/certbot/venv/bin/python2.7 - setuptools pkg_resources pip wheel failed with error code 2 通过搜索，找到了原因是说，系统安装了多个版本的python，那么怎么解决呢？解决方法： 12apt-get purge python-virtualenv python3-virtualenv virtualenvpip install virtualenv 然后再次执行ssl证书生成命令： 1./letsencrypt-auto certonly --standalone -d yourwebsite.com --email youremail.com 正确之后会出现图形界面输入邮箱、条款、等信息（略…） 当出现以下信息时，则证明你的证书已申请成功： 12345678IMPORTANT NOTES:- Congratulations! Your certificate and chain have been saved at/etc/letsencrypt/live/yourwebsite.com/fullchain.pem. Your cert willexpire on 2017-12-26. To obtain a new version of the certificate inthe future, simply run Let&apos;s Encrypt again.- If you like Let&apos;s Encrypt, please consider supporting our work by:Donating to ISRG / Let&apos;s Encrypt: https://letsencrypt.org/donateDonating to EFF: https://eff.org/donate-le 二 、配置生成证书后。生成的位置位于/etc/letsencrypt/live/你的域名/ 目录下（记得备份下）。文件介绍： 文件名 内容 cert.pem 服务端证书 chain.pem 浏览器需要的所有证书,但不包括服务端证书，比如根证书和中间证书 fullchain.pem 包括了cert.pem和chain.pem的内容 privkey.pem 证书的私钥 在这里我们只需要两个文件 fullchain.pem和privkey.pem 在nginx配置文件的server中增加下面代码： 12345678server &#123; listen 443 ssl; listen [::]:443 ssl ipv6only=on; root /wwwroot/hs/hs.yourwebsite.org; ssl on; ssl_certificate /etc/letsencrypt/live/hs.yourwebsite.org/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/hs.yourwebsite.org/privkey.pem;&#125; 12ssl_certificate /etc/letsencrypt/live/hs.yourwebsite.org/fullchain.pem; #对应位置要写对ssl_certificate_key /etc/letsencrypt/live/hs.yourwebsite.org/privkey.pem;#对应位置要写对 重启nginx 1service nginx start 打开网站：https://your.website.com 如果看到浏览器的绿色标志，恭喜你设置成功！ 三、 更新以及自动更新手动更新：./letsencrypt-auto renew 自动更新：首先创建脚本任务，保存目录为你要想保存到的目录下面，创建 /etc/letsssl/restartup.sh 在这里我把脚本文件存放在了/etc/letsssl/目录下。 脚本代码:1234567#!/bin/sh# This script renews all the Let&apos;s Encrypt certificates with a validity &lt; 30 daysif ! /letsencrypt/letsencrypt-auto renew &gt; /var/log/letsencrypt/renew.log 2&gt;&amp;1 ; thenecho Automated renewal failed:service nginx reload;exit 1;fi增加权限：chmod +x 设定的脚本.sh;创建定时任务：12crontab -e 0 0 3 * * /bin/sh /etc/letsssl/restartup.sh &gt;/dev/null 2&gt;&amp;1 &amp; #每月1号凌晨3点执行 四、撤销证书执行以下代码就可直接撤销证书：1./letsencrypt-auto revoke --cert-path /etc/letsencrypt/live/yourwebsite.com/cert.pem]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
</search>
